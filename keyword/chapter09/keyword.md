# 💡 9주차 키워드 💡
<br>

## 1. Spring Data JPA의 Paging

[Paging이란?]<br>사용자가 어떠한 데이터를 요청했을 때, 전체 데이터 중 일부를 원하는 정렬 방식으로 보여주는 것이다.

### 1-1. Page

[정의]<br>전체 페이지 개수와 전체 카운트 쿼리를 포함한 정확한 페이징 정보를 제공한다.

[특징]<br>
1. count 쿼리를 통해 전체 개수를 계산한다.
2. 총 몇 페이지가 있는지를 알고 있어야 하는 경우 적합하다.
3. Pageable을 인자로 받고, Page<T>를 반환하는 메서드를 사용한다.

[반환되는 Page 객체가 제공하는 정보]<br>
1. getContent() : 현재 페이지의 데이터 리스트
2. getTotalPages() : 전체 페이지 수
3. getTotalElements() : 전체 데이터 수
4. getNumber() : 현재 페이지 번호
5. isFirst(), isLast()

[언제 사용할까?]<br>
1. 전체 페이지 수, 전체 데이터 수가 필요한 경우
2. 정확한 페이지 네비게이션이 필요한 경우

### 1-2. Slice

[정의]Page보다 가볍고 빠른 방식으로, 다음 페이지가 있는지 여부만 판단한다.

[특징]<br>
1. count 쿼리를 실행하지 않아 빠르다.
2. 다음 페이지 존재 여부만 판단하기 위해 요청한 데이터 개수 + 1 만큼 조회한다.
3. Pageable을 인자로 받고, Slice<T>를 반환하는 메서드를 사용한다.

[반환되는 Slice 객체가 제공하는 정보]<br>
1. getContent() : 현재 페이지의 데이터 리스트
2. hasNext() : 다음 페이지가 있는지
3. hasPrevious() : 이전 페이지가 있는지
4. isFirst(), isLast()

[언제 사용할까?]<br>
1. 무한 스크롤을 하고자 하는 경우
2. 전체 개수나 총 페이지 수가 불필요한 경우
3. 성능이 중요한 대용량 조회에서 유리하다.

<br>

## 2. 객체 그래프 탐색

[정의]<br>한 객체에서 연관된 다른 객체를 참조해서 정보를 얻는 것.

[종류]<br>
1. 단방향 탐색 : 한 쪽에서만 참조 가능
2. 양방향 탐색 : 양쪽에서 서로 탐색 가능

[왜 중요할까?]<br>단일 객체만 사용하는 것이 아니라 객체들의 관계를 통해 데이터를 다루기 때문!!!!!

[주의점]<br>
1. 지연 로딩 : 연관된 엔티티를 실제 사용할 때 조회.
2. N+1 문제 : 특정 엔티티를 조회할 때 관련된 연관 엔티티를 탐색하면서 추가적인 쿼리가 예상보다 훨씬 많이 실행되는 상황.
3. 복잡성이 증가한다.

[N+1 문제 해결 방법]<br>
1. Fetch Join : JPQL에서 fetch join을 사용해 부모 엔티티와 연관된 자식 엔티티를 한 번에 가져온다.
2. @EntityGraph : JPA의 @EntityGraph를 사용해서 특정 연관 관계를 즉시 로딩으로 변경한다.
3. @BatchSize : 연관 엔티티를 한 번에 로드하여 쿼리 호출 횟수를 줄인다.
4. DTO로 직접 조회 : 엔티티가 아닌 필요한 데이터만 담는 DTO를 사용해 직접 조회한다.